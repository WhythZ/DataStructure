#ifndef _HEAP_SORT_HPP_
#define _HEAP_SORT_HPP_

#include <vector>
#include "SortingStates.hpp"

//向下渗流，传入一个尺寸而不是直接使用_list.size()的原因是我们在最后将最大堆变为有序列表的过程中，需要利用到列表末尾的空位来存放每轮Pop出来的堆顶值x
//在Pop之后我们会将列表末尾的y放到堆顶让其向下渗流，此时我们若不手动限制_size的话，刚刚被我们Pop出来放到列表尾部的值x又会被渗流下来的y所取代
template <typename T>
void PercolateDown(std::vector<T>& _list, size_t _size, typename std::vector<T>::iterator& _itr, SortingStates& _states)
{
    //用于存储指向_itr的两个子节点的迭代器
    typename std::vector<T>::iterator _l, _r;

    //获取_itr在列表中的索引
    size_t _idxItr = std::distance(_list.begin(), _itr);
    //获取左右子节点的索引值，若超出范围则说明没有，直接置空
    size_t _idxR = 2 * _idxItr + 2;
    _r = (_idxR >= _size) ? _list.end() : _list.begin() + _idxR;
    size_t _idxL = 2 * _idxItr + 1;
    _l = (_idxL >= _size) ? _list.end() : _list.begin() + _idxL;

    //若到达叶节点，则直接返回（此处_list.end()是作为类似nullptr的存在）
    if (_l == _list.end() && _r == _list.end())
        return;

    //获取左右子节点中值最大的那个
    typename std::vector<T>::iterator _maxChild = (*_l > *_r) ? _l : _r;
    if (*_itr < *_maxChild)
    {
        //交换二者位置确保大的在上面（std::iter_swap并未交换两个迭代器指向的位置，交换的是两个位置上的值）
        std::iter_swap(_itr, _maxChild);

        #pragma region StatesRecord
        //标记std::swap操作
        size_t _idx1 = std::distance(_list.begin(), _itr);
        size_t _idx2 = std::distance(_list.begin(), _maxChild);
        std::vector<size_t> _tags = { _idx1, _idx2 };
        _states.EmplaceBack(_list, _tags);
        #pragma endregion

        //递归调用向下渗流
        PercolateDown(_list, _size, _maxChild, _states);
    }
}

//堆排序：
template <typename T>
void HeapSort(std::vector<T>& _list, SortingStates& _states)
{
    #pragma region StatesRecord
    //记录初始状态
    _states.EmplaceBack(_list);
    #pragma endregion

    //传入列表的底层开始，向上逐层遍历，让每个节点向下渗流，经历此循环n次后列表便变形为了最大堆
    for (typename std::vector<T>::iterator _itr = _list.end() - 1; _itr >= _list.begin(); _itr--)
    {
        PercolateDown(_list, _list.size(), _itr, _states);
    }
    
    //取出最大堆的堆顶元素，放到列表未排序部分的末尾，重复此操作(n-1)次便完成了排序
    for (size_t i = 1; i < _list.size(); i++)
    {
        //将列表首项即最大值与未排序部分的末尾元素交换，注意此处是减去i
        std::iter_swap(_list.begin(), _list.end() - i);

        #pragma region StatesRecord
        //标记std::swap操作
        std::vector<size_t> _tags = { 0, _list.size() - i };
        _states.EmplaceBack(_list, _tags);
        #pragma endregion

        //让此时的堆顶向下渗流恢复，注意此处我们让渗流考虑的_size减去了i，这是防止列表末尾已经排序好的元素收到破坏
        typename std::vector<T>::iterator _top = _list.begin();
        PercolateDown(_list, _list.size() - i, _top, _states);
    }
}

// ##LengthOfUnorderedList=15
// ##HeapSort
// [0]:     14 , 2 , 5 , 12 , 3 , 9 , 13 , 1 , 10 , 15 , 8 , 6 , 7 , 4 , 11
// [1]:     14 , 2 , 5 , 12 ,<15>, 9 , 13 , 1 , 10 ,<3>, 8 , 6 , 7 , 4 , 11
// [2]:     14 , 2 ,<13>, 12 , 15 , 9 ,<5>, 1 , 10 , 3 , 8 , 6 , 7 , 4 , 11
// [3]:     14 , 2 , 13 , 12 , 15 , 9 ,<11>, 1 , 10 , 3 , 8 , 6 , 7 , 4 ,<5>
// [4]:     14 ,<15>, 13 , 12 ,<2>, 9 , 11 , 1 , 10 , 3 , 8 , 6 , 7 , 4 , 5
// [5]:     14 , 15 , 13 , 12 ,<8>, 9 , 11 , 1 , 10 , 3 ,<2>, 6 , 7 , 4 , 5
// [6]:    <15>,<14>, 13 , 12 , 8 , 9 , 11 , 1 , 10 , 3 , 2 , 6 , 7 , 4 , 5
//
// [7]:    <5>, 14 , 13 , 12 , 8 , 9 , 11 , 1 , 10 , 3 , 2 , 6 , 7 , 4 ,<15>
// [8]:    <14>,<5>, 13 , 12 , 8 , 9 , 11 , 1 , 10 , 3 , 2 , 6 , 7 , 4 , 15
// [9]:     14 ,<12>, 13 ,<5>, 8 , 9 , 11 , 1 , 10 , 3 , 2 , 6 , 7 , 4 , 15
// [10]:    14 , 12 , 13 ,<10>, 8 , 9 , 11 , 1 ,<5>, 3 , 2 , 6 , 7 , 4 , 15
// [11]:   <4>, 12 , 13 , 10 , 8 , 9 , 11 , 1 , 5 , 3 , 2 , 6 , 7 ,<14>, 15
// [12]:   <13>, 12 ,<4>, 10 , 8 , 9 , 11 , 1 , 5 , 3 , 2 , 6 , 7 , 14 , 15
// [13]:    13 , 12 ,<11>, 10 , 8 , 9 ,<4>, 1 , 5 , 3 , 2 , 6 , 7 , 14 , 15
// [14]:   <7>, 12 , 11 , 10 , 8 , 9 , 4 , 1 , 5 , 3 , 2 , 6 ,<13>, 14 , 15
// [15]:   <12>,<7>, 11 , 10 , 8 , 9 , 4 , 1 , 5 , 3 , 2 , 6 , 13 , 14 , 15
// [16]:    12 ,<10>, 11 ,<7>, 8 , 9 , 4 , 1 , 5 , 3 , 2 , 6 , 13 , 14 , 15
// [17]:   <6>, 10 , 11 , 7 , 8 , 9 , 4 , 1 , 5 , 3 , 2 ,<12>, 13 , 14 , 15
// [18]:   <11>, 10 ,<6>, 7 , 8 , 9 , 4 , 1 , 5 , 3 , 2 , 12 , 13 , 14 , 15
// [19]:    11 , 10 ,<9>, 7 , 8 ,<6>, 4 , 1 , 5 , 3 , 2 , 12 , 13 , 14 , 15
// [20]:   <2>, 10 , 9 , 7 , 8 , 6 , 4 , 1 , 5 , 3 ,<11>, 12 , 13 , 14 , 15
// [21]:   <10>,<2>, 9 , 7 , 8 , 6 , 4 , 1 , 5 , 3 , 11 , 12 , 13 , 14 , 15
// [22]:    10 ,<8>, 9 , 7 ,<2>, 6 , 4 , 1 , 5 , 3 , 11 , 12 , 13 , 14 , 15
// [23]:    10 , 8 , 9 , 7 ,<3>, 6 , 4 , 1 , 5 ,<2>, 11 , 12 , 13 , 14 , 15
// [24]:   <2>, 8 , 9 , 7 , 3 , 6 , 4 , 1 , 5 ,<10>, 11 , 12 , 13 , 14 , 15
// [25]:   <9>, 8 ,<2>, 7 , 3 , 6 , 4 , 1 , 5 , 10 , 11 , 12 , 13 , 14 , 15
// [26]:    9 , 8 ,<6>, 7 , 3 ,<2>, 4 , 1 , 5 , 10 , 11 , 12 , 13 , 14 , 15
// [27]:   <5>, 8 , 6 , 7 , 3 , 2 , 4 , 1 ,<9>, 10 , 11 , 12 , 13 , 14 , 15
// [28]:   <8>,<5>, 6 , 7 , 3 , 2 , 4 , 1 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [29]:    8 ,<7>, 6 ,<5>, 3 , 2 , 4 , 1 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [30]:   <1>, 7 , 6 , 5 , 3 , 2 , 4 ,<8>, 9 , 10 , 11 , 12 , 13 , 14 , 15
// [31]:   <7>,<1>, 6 , 5 , 3 , 2 , 4 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [32]:    7 ,<5>, 6 ,<1>, 3 , 2 , 4 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [33]:   <4>, 5 , 6 , 1 , 3 , 2 ,<7>, 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [34]:   <6>, 5 ,<4>, 1 , 3 , 2 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [35]:   <2>, 5 , 4 , 1 , 3 ,<6>, 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [36]:   <5>,<2>, 4 , 1 , 3 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [37]:    5 ,<3>, 4 , 1 ,<2>, 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [38]:   <2>, 3 , 4 , 1 ,<5>, 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [39]:   <4>, 3 ,<2>, 1 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [40]:   <1>, 3 , 2 ,<4>, 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [41]:   <3>,<1>, 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [42]:   <2>, 1 ,<3>, 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15
// [43]:   <1>,<2>, 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15

#endif